import { Schema, InferIn } from "./adapters/types.mjs";
import {
	c as SafeActionResult,
	r as MaybePromise,
	P as Prettify,
	d as SafeActionFn,
	e as SafeStateActionFn,
} from "./index.types-DDvdbgiI.mjs";

/**
 * Type of base utils object passed to `useAction`, `useOptimisticAction` and `useStateAction` hooks.
 */
type HookBaseUtils<S extends Schema | undefined> = {
	/**
	 * @deprecated Actions should not execute on component mount, since they're used to mutate data.
	 */
	executeOnMount?: (undefined extends S
		? {
				input?: undefined;
			}
		: {
				input: S extends Schema ? InferIn<S> : undefined;
			}) & {
		delayMs?: number;
	};
};
/**
 * Type of hooks callbacks. These are executed when action is in a specific state.
 */
type HookCallbacks<ServerError, S extends Schema | undefined, BAS extends readonly Schema[], CVE, CBAVE, Data> = {
	onExecute?: (args: { input: S extends Schema ? InferIn<S> : undefined }) => MaybePromise<unknown>;
	onSuccess?: (args: { data?: Data; input: S extends Schema ? InferIn<S> : undefined }) => MaybePromise<unknown>;
	onError?: (args: {
		error: Prettify<Omit<SafeActionResult<ServerError, S, BAS, CVE, CBAVE, Data>, "data">>;
		input: S extends Schema ? InferIn<S> : undefined;
	}) => MaybePromise<unknown>;
	onSettled?: (args: {
		result: Prettify<SafeActionResult<ServerError, S, BAS, CVE, CBAVE, Data>>;
		input: S extends Schema ? InferIn<S> : undefined;
	}) => MaybePromise<unknown>;
};
/**
 * Type of the safe action function passed to hooks. Same as `SafeActionFn` except it accepts
 * just a single input, without bind arguments.
 */
type HookSafeActionFn<ServerError, S extends Schema | undefined, BAS extends readonly Schema[], CVE, CBAVE, Data> = (
	input: S extends Schema ? InferIn<S> : undefined
) => Promise<SafeActionResult<ServerError, S, BAS, CVE, CBAVE, Data> | undefined>;
/**
 * Type of the stateful safe action function passed to hooks. Same as `SafeStateActionFn` except it accepts
 * just a single input, without bind arguments.
 */
type HookSafeStateActionFn<
	ServerError,
	S extends Schema | undefined,
	BAS extends readonly Schema[],
	CVE,
	CBAVE,
	Data,
> = (
	prevResult: SafeActionResult<ServerError, S, BAS, CVE, CBAVE, Data>,
	input: S extends Schema ? InferIn<S> : undefined
) => Promise<SafeActionResult<ServerError, S, BAS, CVE, CBAVE, Data>>;
/**
 * Type of the action status returned by `useAction`, `useOptimisticAction` and `useStateAction` hooks.
 */
type HookActionStatus = "idle" | "executing" | "hasSucceeded" | "hasErrored";
/**
 * Type of the shorthand status object returned by `useAction`, `useOptimisticAction` and `useStateAction` hooks.
 */
type HookShorthandStatus = {
	isIdle: boolean;
	isExecuting: boolean;
	isTransitioning: boolean;
	isPending: boolean;
	hasSucceeded: boolean;
	hasErrored: boolean;
};
/**
 * Type of the return object of the `useAction` hook.
 */
type UseActionHookReturn<ServerError, S extends Schema | undefined, BAS extends readonly Schema[], CVE, CBAVE, Data> = {
	execute: (input: S extends Schema ? InferIn<S> : void) => void;
	executeAsync: (
		input: S extends Schema ? InferIn<S> : void
	) => Promise<SafeActionResult<ServerError, S, BAS, CVE, CBAVE, Data> | undefined>;
	input: S extends Schema ? InferIn<S> : undefined;
	result: Prettify<SafeActionResult<ServerError, S, BAS, CVE, CBAVE, Data>>;
	reset: () => void;
	status: HookActionStatus;
} & HookShorthandStatus;
/**
 * Type of the return object of the `useOptimisticAction` hook.
 */
type UseOptimisticActionHookReturn<
	ServerError,
	S extends Schema | undefined,
	BAS extends readonly Schema[],
	CVE,
	CBAVE,
	Data,
	State,
> = UseActionHookReturn<ServerError, S, BAS, CVE, CBAVE, Data> &
	HookShorthandStatus & {
		optimisticState: State;
	};
/**
 * Type of the return object of the `useStateAction` hook.
 */
type UseStateActionHookReturn<
	ServerError,
	S extends Schema | undefined,
	BAS extends readonly Schema[],
	CVE,
	CBAVE,
	Data,
> = Omit<UseActionHookReturn<ServerError, S, BAS, CVE, CBAVE, Data>, "executeAsync" | "reset"> & HookShorthandStatus;
/**
 * Type of the return object of the `useAction` hook.
 */
type InferUseActionHookReturn<T extends Function> =
	T extends SafeActionFn<
		infer ServerError,
		infer S extends Schema | undefined,
		infer BAS extends readonly Schema[],
		infer CVE,
		infer CBAVE,
		infer Data
	>
		? UseActionHookReturn<ServerError, S, BAS, CVE, CBAVE, Data>
		: never;
/**
 * Type of the return object of the `useOptimisticAction` hook.
 */
type InferUseOptimisticActionHookReturn<T extends Function, State = any> =
	T extends SafeActionFn<
		infer ServerError,
		infer S extends Schema | undefined,
		infer BAS extends readonly Schema[],
		infer CVE,
		infer CBAVE,
		infer Data
	>
		? UseOptimisticActionHookReturn<ServerError, S, BAS, CVE, CBAVE, Data, State>
		: never;
/**
 * Type of the return object of the `useStateAction` hook.
 */
type InferUseStateActionHookReturn<T extends Function> =
	T extends SafeStateActionFn<
		infer ServerError,
		infer S extends Schema | undefined,
		infer BAS extends readonly Schema[],
		infer CVE,
		infer CBAVE,
		infer Data
	>
		? UseStateActionHookReturn<ServerError, S, BAS, CVE, CBAVE, Data>
		: never;

export type {
	HookSafeActionFn as H,
	InferUseActionHookReturn as I,
	UseActionHookReturn as U,
	HookBaseUtils as a,
	HookCallbacks as b,
	UseOptimisticActionHookReturn as c,
	HookSafeStateActionFn as d,
	HookActionStatus as e,
	HookShorthandStatus as f,
	UseStateActionHookReturn as g,
	InferUseOptimisticActionHookReturn as h,
	InferUseStateActionHookReturn as i,
};
