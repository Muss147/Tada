"use server";

import { prisma } from "@/lib/prisma";
import { authActionClient } from "../safe-action";
import { z } from "zod";

const generateMissionChartsSchema = z.object({
  missionId: z.string(),
});

function getQuestionChartConfig(questionType: string) {
  switch (questionType) {
    case "dropdown":
      return {
        type: "bar",
        chart_type: "BarChartHorizontalCard",
        allowed_chart: [
          "BarChartHorizontalCard",
          "PieChart",
          "BarChartVerticalCard",
        ],
      };

    case "checkbox":
      return {
        type: "bar",
        chart_type: "BarChartHorizontalCard",
        allowed_chart: ["BarChartHorizontalCard", "PieChart"],
      };

    case "boolean":
      return {
        type: "pie",
        chart_type: "PieChart",
        allowed_chart: ["PieChart", "BarChartHorizontalCard"],
      };

    case "rating":
      return {
        type: "bar",
        chart_type: "BarChartHorizontalStackedCard",
        allowed_chart: [
          "BarChartHorizontalStackedCard",
          "BarChartHorizontalCard",
          "LineChart",
          "BarChartVerticalCard",
        ],
      };

    case "text":
    case "comment":
      return {
        type: "kpi",
        chart_type: "ArrayChartCard",
        allowed_chart: ["ArrayChartCard"],
      };

    case "file":
      return {
        type: "kpi",
        chart_type: "not implemented",
        allowed_chart: [],
      };

    default:
      return {
        type: "bar",
        chart_type: "BarChartHorizontalCard",
        allowed_chart: ["BarChartHorizontalCard"],
      };
  }
}

function generateEmptyChartConfig() {
  return {
    value: {
      label: "value",
      color: "hsl(var(--chart-1))",
    },
  };
}

export const generateMissionChartsAction = authActionClient
  .schema(generateMissionChartsSchema)
  .metadata({
    name: "generate-mission-charts-action",
  })
  .action(async ({ parsedInput: { missionId }, ctx: { user } }) => {
    try {
      // 1. Récupérer la mission avec ses sondages
      const mission = await prisma.mission.findUnique({
        where: { id: missionId },
        include: {
          survey: {
            select: {
              id: true,
              name: true,
              questions: true,
            },
          },
        },
      });

      if (!mission) {
        throw new Error("Mission non trouvée");
      }

      if (!mission.survey || mission.survey.length === 0) {
        throw new Error("Aucun sondage trouvé pour cette mission");
      }

      const generatedCharts: any[] = [];
      let dashboardOrder = 1;
      const survey = mission.survey[0]!;

      // Parser les questions du sondage
      const questions =
        typeof survey.questions === "string"
          ? survey.questions
          : (survey?.questions as any).pages[0].elements;

      console.log(questions);

      // Créer un graphique pour chaque question
      if (Array.isArray(questions)) {
        for (const question of questions) {
          if (!question.title || !question.type) {
            continue;
          }

          const chartConfig = getQuestionChartConfig(question.type);

          // Skip les questions non implémentées
          if (chartConfig.chart_type === "not implemented") {
            continue;
          }

          // Créer le modèle QuestionData avec data vide
          const questionDataModel = {
            question: question.title,
            type: question.type,
            chart_type: chartConfig.chart_type,
            allowed_chart: chartConfig.allowed_chart,
            participants_responded: 0, // Sera calculé en temps réel
            data: [], // Données vides - seront calculées en temps réel côté app
            config: generateEmptyChartConfig(),
          };

          const chart = await prisma.missionChart.create({
            data: {
              missionId,
              surveyId: survey.id,
              name: question.title,
              type: chartConfig.type,
              subType: chartConfig.chart_type,
              title: question.title,
              description: `Graphique pour la question: ${question.title}`,
              chartData: questionDataModel, // Stockage du modèle complet
              dashboardOrder: dashboardOrder++,
              isAutoGenerated: true,
              status: "published",
              language: "fr",
            },
          });

          generatedCharts.push(chart);
        }
      }

      return {
        success: true,
        data: {
          chartsGenerated: generatedCharts.length,
          charts: generatedCharts,
        },
      };
    } catch (error) {
      console.error("[GENERATE_MISSION_CHARTS_ERROR]", error);
      return {
        success: false,
        error:
          error instanceof Error ? error.message : "Une erreur est survenue",
      };
    }
  });
